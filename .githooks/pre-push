#!/bin/bash
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“„ VALIDACIÃ“N DE DOCUMENTACIÃ“N PHPDOC
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
echo "ğŸ” Iniciando validaciÃ³n PHPDoc con PHPCS..."
echo "ğŸ“… Fecha: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
echo "ğŸ‘¤ Usuario: $(git config user.name)"

# Obtener el hash del Ãºltimo commit local y remoto
local_commit=$(git rev-parse HEAD)
remote_commit=$(git rev-parse @{u} 2>/dev/null || git hash-object -t tree /dev/null)

# Crear directorio temporal
TEMP_DIR=$(mktemp -d)
ERROR=0

# FunciÃ³n para extraer y validar una funciÃ³n modificada
validate_modified_function() {
    local file=$1
    local start_line=$2
    local content=$3
    local temp_file="${TEMP_DIR}/temp.php"

    # Buscar el inicio del bloque de documentaciÃ³n
    local doc_start=$start_line
    while [ $doc_start -gt 1 ]; do
        local line=$(echo "$content" | sed "${doc_start}q;d")
        if [[ $line =~ ^\s*(/\*\*) ]]; then
            break
        elif [[ $line =~ ^[[:space:]]*(public|private|protected|function|class)[[:space:]]+ ]]; then
            doc_start=$((doc_start - 1))
            continue
        fi
        doc_start=$((doc_start - 1))
    done

    # Buscar el final de la funciÃ³n
    local func_end=$start_line
    while true; do
        local line=$(echo "$content" | sed "${func_end}q;d")
        if [[ $line =~ ^\s*} ]]; then
            func_end=$((func_end + 1))
            break
        elif [ -z "$line" ]; then
            break
        fi
        func_end=$((func_end + 1))
    done

    # Extraer solo la funciÃ³n modificada
    echo "<?php" > "$temp_file"
    echo "$content" | sed -n "${doc_start},${func_end}p" >> "$temp_file"

    echo "Validando funciÃ³n en $file (lÃ­neas $doc_start-$func_end):"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    cat "$temp_file"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

    # Ejecutar phpcs con salida detallada
    if ! vendor/bin/phpcs --standard=phpcs.xml "$temp_file"; then
        echo "âŒ Error de documentaciÃ³n en la funciÃ³n"
        return 1
    fi
    return 0
}

# Procesar cada archivo PHP modificado
git diff --name-only $remote_commit $local_commit | grep -E '\.php$' | while read -r file; do
    if [ -f "$file" ]; then
        echo "ğŸ“‚ Analizando $file..."
        
        # Obtener el contenido actual del archivo
        content=$(git show $local_commit:"$file")
        
        # Obtener las lÃ­neas modificadas
        git diff -U0 $remote_commit $local_commit -- "$file" | grep -E '^@@' | while read -r hunk; do
            if [[ $hunk =~ \+([0-9]+) ]]; then
                modified_line="${BASH_REMATCH[1]}"
                
                # Validar la funciÃ³n que contiene la lÃ­nea modificada
                if ! validate_modified_function "$file" "$modified_line" "$content"; then
                    ERROR=1
                    echo "âŒ Error encontrado en $file cerca de la lÃ­nea $modified_line"
                    exit 1
                fi
            fi
        done
        
        # Si hay error en el subshell, propagar
        if [ $? -eq 1 ]; then
            ERROR=1
            break
        fi
    fi
done

# Limpiar archivos temporales
rm -rf "$TEMP_DIR"

# Verificar si hubo errores
if [ $ERROR -ne 0 ]; then
    echo "âŒ Se encontraron errores en la documentaciÃ³n PHPDoc. Corrige los problemas antes de hacer push."
    exit 1
fi

echo "âœ… ValidaciÃ³n exitosa. Continuando con el push."
exit 0