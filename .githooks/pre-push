#!/bin/bash

# Contin√∫a con la validaci√≥n de PHPDoc
echo "üîç Iniciando validaci√≥n PHPDoc con PHPCS..."
echo "üìÖ Fecha: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
echo "üë§ Usuario: $(git config user.name)"

# Crear un archivo temporal para almacenar el estado de error
ERROR_FILE=$(mktemp)
echo "0" > "$ERROR_FILE"

# Obtener el hash del √∫ltimo commit local y remoto
local_commit=$(git rev-parse HEAD)
remote_commit=$(git rev-parse @{u} 2>/dev/null || git hash-object -t tree /dev/null)

# Crear directorio temporal
TEMP_DIR=$(mktemp -d)

# Funci√≥n para encontrar el rango completo de una funci√≥n
find_function_range() {
    local file=$1
    local target_line=$2
    local content=$3
    
    # Buscar hacia arriba hasta encontrar el inicio de la funci√≥n actual
    local start_line=$target_line
    while [ $start_line -gt 1 ]; do
        local line=$(echo "$content" | sed "${start_line}q;d")
        # Si encontramos el inicio de otra funci√≥n, retrocedemos
        if [ $start_line -lt $target_line ] && [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]]; then
            start_line=$((start_line + 1))
            break
        fi
        # Si encontramos el inicio de la funci√≥n actual o su docblock
        if [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]] || [[ $line =~ ^\s*(/\*\*) ]]; then
            break
        fi
        start_line=$((start_line - 1))
    done
    
    # Si encontramos un docblock, asegurarnos de tener su inicio
    if [[ $(echo "$content" | sed "${start_line}q;d") =~ ^\s*(/\*\*) ]]; then
        while [ $start_line -gt 1 ]; do
            local prev_line=$((start_line - 1))
            local line=$(echo "$content" | sed "${prev_line}q;d")
            if [[ ! $line =~ ^\s*(/\*\*|\*) ]]; then
                break
            fi
            start_line=$prev_line
        done
    fi
    
    # Buscar hacia abajo hasta encontrar el final de esta funci√≥n espec√≠fica
    local end_line=$target_line
    local brace_count=0
    local found_function=false
    
    while true; do
        local line=$(echo "$content" | sed "${end_line}q;d")
        
        if [[ $line =~ \{ ]]; then
            brace_count=$((brace_count + 1))
            found_function=true
        fi
        if [[ $line =~ \} ]]; then
            brace_count=$((brace_count - 1))
            if [ $found_function = true ] && [ $brace_count -eq 0 ]; then
                break
            fi
        fi
        
        # Si encontramos el inicio de la siguiente funci√≥n, retrocedemos
        if [ $end_line -gt $target_line ] && [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]]; then
            end_line=$((end_line - 1))
            break
        fi
        
        end_line=$((end_line + 1))
        
        # Evitar bucle infinito
        if [ $end_line -gt 99999 ]; then
            break
        fi
    done
    
    echo "$start_line $end_line"
}

# Funci√≥n para validar una funci√≥n espec√≠fica
validate_function() {
    local file=$1
    local start_line=$2
    local end_line=$3
    local content=$4
    local temp_file="${TEMP_DIR}/temp.php"
    local line_offset=$((start_line - 2))  # -2 por el <?php y la funci√≥n
    
    # Crear archivo temporal con solo la funci√≥n a validar
    echo "<?php" > "$temp_file"
    echo "$content" | sed -n "${start_line},${end_line}p" >> "$temp_file"
    
    echo "Validando funci√≥n (l√≠neas $start_line-$end_line):"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    cat "$temp_file"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Ejecutar phpcs aislado
    if ! phpcs_output=$(vendor/bin/phpcs --standard=phpcs.xml "$temp_file" 2>&1); then
        # Ajustar los n√∫meros de l√≠nea en la salida
        while IFS= read -r line; do
            if [[ $line =~ ^[[:space:]]*([0-9]+)[[:space:]]*\| ]]; then
                # Calcular la l√≠nea real en el archivo original
                reported_line="${BASH_REMATCH[1]}"
                actual_line=$((reported_line + line_offset))
                # Reemplazar el n√∫mero de l√≠nea en la salida
                echo "$line" | sed "s/^[[:space:]]*$reported_line[[:space:]]*|/L√≠nea $actual_line:|/"
            else
                echo "$line"
            fi
        done <<< "$phpcs_output"
        
        echo "‚ùå Error de documentaci√≥n en la funci√≥n"
        echo "1" > "$ERROR_FILE"
        return 1
    fi
    
    return 0
}

# Procesar archivos modificados
git diff --name-only $remote_commit $local_commit | grep -E '\.php$' | while read -r file; do
    if [ ! -f "$file" ]; then
        echo "‚ÑπÔ∏è Archivo eliminado o no encontrado: $file. Ignorando..."
        continue
    fi

    echo "üìÇ Analizando $file..."
    
    # Obtener contenido actual del archivo
    content=$(git show $local_commit:"$file")
    
    # Obtener las l√≠neas modificadas
    git diff -U0 $remote_commit $local_commit -- "$file" | grep -E '^@@' | while read -r hunk; do
        if [[ $hunk =~ \+([0-9]+)(,[0-9]+)? ]]; then
            modified_line=${BASH_REMATCH[1]}
            
            # Encontrar el rango completo de la funci√≥n
            range=$(find_function_range "$file" "$modified_line" "$content")
            start_line=$(echo $range | cut -d' ' -f1)
            end_line=$(echo $range | cut -d' ' -f2)
            
            if ! validate_function "$file" "$start_line" "$end_line" "$content"; then
                exit 1
            fi
        fi
    done
    
    # Verificar error en subshell
    if [ $? -ne 0 ]; then
        echo "1" > "$ERROR_FILE"
        break
    fi
done

# Leer estado de error
ERROR=$(cat "$ERROR_FILE")

# Limpiar archivos temporales
rm -rf "$TEMP_DIR" "$ERROR_FILE"

# Verificar si hubo errores
if [ "$ERROR" -ne 0 ]; then
    echo "‚ùå Se encontraron errores en la documentaci√≥n PHPDoc. Corrige los problemas antes de hacer push."
    exit 1
fi

echo "‚úÖ Validaci√≥n exitosa. Continuando con el push."
exit 0