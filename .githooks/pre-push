#!/bin/bash

set -e  # Salir inmediatamente si ocurre un error
set -o pipefail  # Fallar si un comando dentro de un pipe falla

# Crear directorios temporales para almacenar errores y limpiar al terminar
TEMP_DIR=$(mktemp -d)
ERROR_FILE=$(mktemp)

cleanup() {
    rm -rf "$TEMP_DIR" "$ERROR_FILE"
}
trap cleanup EXIT

# Comienzo de la validaci√≥n
echo "üîç Iniciando validaci√≥n PHPDoc con PHPCS..."
echo "üìÖ Fecha: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
echo "üë§ Usuario: $(git config user.name)"

# Obtener el hash del √∫ltimo commit local y remoto
echo "üîç Obteniendo commits locales y remotos..."
local_commit=$(git rev-parse HEAD)
remote_commit=$(git rev-parse @{u} 2>/dev/null || git hash-object -t tree /dev/null)

echo "üîç Commit local: $local_commit"
echo "üîç Commit remoto: $remote_commit"

# Definici√≥n de la funci√≥n para encontrar el rango de una funci√≥n
find_function_range() {
    local file=$1
    local target_line=$2
    local content=$3

    # Buscar hacia arriba hasta encontrar el inicio de la funci√≥n actual
    local start_line=$target_line
    while [ $start_line -gt 1 ]; do
        local line=$(echo "$content" | sed "${start_line}q;d")
        if [ $start_line -lt $target_line ] && [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]]; then
            start_line=$((start_line + 1))
            break
        fi
        if [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]] || [[ $line =~ ^\s*(/\*\*) ]]; then
            break
        fi
        start_line=$((start_line - 1))
    done

    # Si encontramos un docblock, asegurarnos de tener su inicio
    if [[ $(echo "$content" | sed "${start_line}q;d") =~ ^\s*(/\*\*) ]]; then
        while [ $start_line -gt 1 ]; do
            local prev_line=$((start_line - 1))
            local line=$(echo "$content" | sed "${prev_line}q;d")
            if [[ ! $line =~ ^\s*(/\*\*|\*) ]]; then
                break
            fi
            start_line=$prev_line
        done
    fi

    # Buscar hacia abajo hasta encontrar el final de esta funci√≥n espec√≠fica
    local end_line=$target_line
    local brace_count=0
    local found_function=false

    while true; do
        local line=$(echo "$content" | sed "${end_line}q;d")
        if [[ $line =~ \{ ]]; then
            brace_count=$((brace_count + 1))
            found_function=true
        fi
        if [[ $line =~ \} ]]; then
            brace_count=$((brace_count - 1))
            if [ $found_function = true ] && [ $brace_count -eq 0 ]; then
                break
            fi
        fi
        if [ $end_line -gt $target_line ] && [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]]; then
            end_line=$((end_line - 1))
            break
        fi
        end_line=$((end_line + 1))
        if [ $end_line -gt 99999 ]; then
            break
        fi
    done

    echo "$start_line $end_line"
}

# Validar una funci√≥n espec√≠fica
validate_function() {
    local file=$1
    local start_line=$2
    local end_line=$3
    local content=$4
    local temp_file="${TEMP_DIR}/temp.php"
    local line_offset=$((start_line - 2))  # -2 por el <?php y la funci√≥n

    # Crear archivo temporal con solo la funci√≥n a validar
    echo "<?php" > "$temp_file"
    echo "$content" | sed -n "${start_line},${end_line}p" >> "$temp_file"

    echo "Validando funci√≥n (l√≠neas $start_line-$end_line):"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    cat "$temp_file"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    # Ejecutar phpcs aislado
    if ! phpcs_output=$(vendor/bin/phpcs --standard=phpcs.xml "$temp_file" 2>&1); then
        # Ajustar los n√∫meros de l√≠nea en la salida
        while IFS= read -r line; do
            if [[ $line =~ ^[[:space:]]*([0-9]+)[[:space:]]*\| ]]; then
                reported_line="${BASH_REMATCH[1]}"
                actual_line=$((reported_line + line_offset))
                echo "$line" | sed "s/^[[:space:]]*$reported_line[[:space:]]*|/L√≠nea $actual_line:|/"
            else
                echo "$line"
            fi
        done <<< "$phpcs_output"

        echo "‚ùå Error de documentaci√≥n en la funci√≥n"
        echo "1" > "$ERROR_FILE"
        return 1
    fi

    return 0
}

# Procesar archivos modificados
git diff --name-only $remote_commit $local_commit | grep -E '\.php$' | while read -r file; do
    echo "üìÇ Procesando archivo: $file"
    if [ ! -f "$file" ]; then
        echo "‚ÑπÔ∏è Archivo eliminado o no encontrado: $file. Ignorando..."
        continue
    fi

    content=$(git show $local_commit:"$file") || { echo "‚ùå Error al obtener contenido de $file"; exit 1; }

    git diff -U0 $remote_commit $local_commit -- "$file" | grep -E '^@@' | while read -r hunk; do
        if [[ $hunk =~ \+([0-9]+)(,[0-9]+)? ]]; then
            modified_line=${BASH_REMATCH[1]}
            echo "üîç Llamando a find_function_range para el archivo $file en la l√≠nea $modified_line..."
            range=$(find_function_range "$file" "$modified_line" "$content") || { echo "‚ùå Error al llamar a find_function_range"; exit 1; }
            start_line=$(echo $range | cut -d' ' -f1)
            end_line=$(echo $range | cut -d' ' -f2)

            if ! validate_function "$file" "$start_line" "$end_line" "$content"; then
                exit 1
            fi
        fi
    done
done

ERROR=$(cat "$ERROR_FILE")

if [ "$ERROR" -ne 0 ]; then
    echo "‚ùå Se encontraron errores en la documentaci√≥n PHPDoc. Corrige los problemas antes de hacer push."
    exit 1
fi

echo "‚úÖ Validaci√≥n exitosa. Continuando con el push."
exit 0