#!/bin/bash

set -e  # Salir inmediatamente si ocurre un error
set -o pipefail  # Fallar si un comando dentro de un pipe falla

# Crear directorios temporales para almacenar errores y limpiar al terminar
TEMP_DIR=$(mktemp -d)
ERROR_FILE=$(mktemp)

cleanup() {
    echo "üßπ Limpiando archivos temporales..."
    rm -rf "$TEMP_DIR" "$ERROR_FILE"
}
trap cleanup EXIT

# Comienzo de la validaci√≥n
echo "üîç [Inicio] Iniciando validaci√≥n PHPDoc con PHPCS..."
echo "üìÖ [Fecha] $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
echo "üë§ [Usuario] $(git config user.name)"

# Obtener el hash del √∫ltimo commit local y remoto
echo "üîç [Commits] Obteniendo commits locales y remotos..."
local_commit=$(git rev-parse HEAD) || { echo "‚ùå [Error] No se pudo obtener el commit local"; exit 1; }
remote_commit=$(git rev-parse @{u} 2>/dev/null || git hash-object -t tree /dev/null) || { echo "‚ùå [Error] No se pudo obtener el commit remoto"; exit 1; }

echo "üîç [Commits] Commit local: $local_commit"
echo "üîç [Commits] Commit remoto: $remote_commit"

# Validar un rango de l√≠neas de una funci√≥n
find_function_range() {
    local file=$1
    local target_line=$2
    local content=$3

    echo "üîé [Funci√≥n] Buscando rango en $file, l√≠nea objetivo: $target_line"

    # Buscar hacia arriba hasta encontrar el inicio de la funci√≥n actual
    local start_line=$target_line
    while [ $start_line -gt 1 ]; do
        local line=$(echo "$content" | sed "${start_line}q;d")
        if [ $start_line -lt $target_line ] && [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]]; then
            start_line=$((start_line + 1))
            break
        fi
        if [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]] || [[ $line =~ ^\s*(/\*\*) ]]; then
            break
        fi
        start_line=$((start_line - 1))
    done

    # Si encontramos un docblock, asegurarnos de incluir su inicio
    if [[ $(echo "$content" | sed "${start_line}q;d") =~ ^\s*(/\*\*) ]]; then
        while [ $start_line -gt 1 ]; do
            local prev_line=$((start_line - 1))
            local line=$(echo "$content" | sed "${prev_line}q;d")
            if [[ ! $line =~ ^\s*(/\*\*|\*) ]]; then
                break
            fi
            start_line=$prev_line
        done
    fi

    # Buscar hacia abajo hasta encontrar el final de la funci√≥n
    local end_line=$target_line
    local brace_count=0
    local found_function=false

    while true; do
        local line=$(echo "$content" | sed "${end_line}q;d")
        if [[ $line =~ \{ ]]; then
            brace_count=$((brace_count + 1))
            found_function=true
        fi
        if [[ $line =~ \} ]]; then
            brace_count=$((brace_count - 1))
            if [ $found_function = true ] && [ $brace_count -eq 0 ]; then
                break
            fi
        fi
        if [ $end_line -gt $target_line ] && [[ $line =~ ^[[:space:]]*(public|private|protected|function)[[:space:]]+.*\( ]]; then
            end_line=$((end_line - 1))
            break
        fi
        end_line=$((end_line + 1))
        if [ $end_line -gt 99999 ]; then
            echo "‚ùå [Error] Rango de b√∫squeda excedi√≥ los l√≠mites en $file"
            exit 1
        fi
    done

    echo "$start_line $end_line"
}

# Validar una funci√≥n espec√≠fica
validate_function() {
    local file=$1
    local start_line=$2
    local end_line=$3
    local content=$4
    local temp_file="${TEMP_DIR}/temp.php"
    local line_offset=$((start_line - 2))  # -2 por el <?php y la funci√≥n

    echo "üìã [Validaci√≥n] Validando funci√≥n en $file (l√≠neas $start_line-$end_line)"

    # Crear archivo temporal con solo la funci√≥n a validar
    echo "<?php" > "$temp_file"
    echo "$content" | sed -n "${start_line},${end_line}p" >> "$temp_file"

    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    cat "$temp_file"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

    # Ejecutar PHPCS
    if ! phpcs_output=$(vendor/bin/phpcs --standard=phpcs.xml "$temp_file" 2>&1); then
        echo "‚ùå [PHP_CodeSniffer] Errores detectados:"
        echo "$phpcs_output"
        echo "1" > "$ERROR_FILE"
        return 1
    fi

    echo "‚úÖ [Validaci√≥n] Funci√≥n validada correctamente."
    return 0
}

# Procesar archivos modificados
echo "üîç [Archivos] Analizando archivos modificados..."
git diff --name-only $remote_commit $local_commit | grep -E '\.php$' | while read -r file; do
    echo "üìÇ [Archivo] Procesando: $file"
    if [ ! -f "$file" ]; then
        echo "‚ÑπÔ∏è [Info] Archivo eliminado o no encontrado: $file. Ignorando..."
        continue
    fi

    # Obtener contenido del archivo
    content=$(git show $local_commit:"$file") || { echo "‚ùå [Error] No se pudo obtener contenido de $file"; exit 1; }

    # Obtener l√≠neas modificadas
    git diff -U0 $remote_commit $local_commit -- "$file" | grep -E '^@@' | while read -r hunk; do
        if [[ $hunk =~ \+([0-9]+)(,[0-9]+)? ]]; then
            modified_line=${BASH_REMATCH[1]}
            echo "üîç [Hunk] Analizando l√≠nea modificada: $modified_line en $file"
            range=$(find_function_range "$file" "$modified_line" "$content") || { echo "‚ùå [Error] No se pudo calcular rango para $file"; exit 1; }
            start_line=$(echo $range | cut -d' ' -f1)
            end_line=$(echo $range | cut -d' ' -f2)

            if ! validate_function "$file" "$start_line" "$end_line" "$content"; then
                exit 1
            fi
        fi
    done
done

# Verificar errores globales
ERROR=$(cat "$ERROR_FILE")

if [ "$ERROR" -ne 0 ]; then
    echo "‚ùå [Error Global] Se encontraron errores en la documentaci√≥n PHPDoc. Corrige los problemas antes de hacer push."
    exit 1
fi

echo "‚úÖ [√âxito] Validaci√≥n completada. Continuando con el push."
exit 0